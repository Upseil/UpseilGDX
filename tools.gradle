// UpseilGDX Tools - Gradle Utilites

/** pixelateFonts Configuration
 *   Filters every pixel in the fonts .png file:
 *     if pixel.rgb == filter.rgb && pixel.alpha >= alphaThreshold {
 *       pixel.rgba = filter.rgba
 *     } else {
 *       pixel.rgba = transparent.rgba
 *     }
 *
 *   Pattern for the path to the font folder containing the .fnt and .png:
 *     fontPath = <rawFontRoot>/<fontFamilyName>/fnt-<fontSize>/
 *     fntPath = <fontPath>/<fontFamilyName>-<fontSize>.fnt
 *     pngPath = <fontPath>/<fontFamilyName>-<fontSize>.png
 */
ext {
    rawFontRoot = 'relative path to root font folder'
    fontsToPixelate = [
        ['fontFamilyName', [
                ['fontSize as Integer', 'filterColor as Hex-String', 0 /*alphaThreshold as Integer*/]
            ]
        ]
    ]
}

/** packSkins/deploySkins Configuration
 *   Packs the fonts and components of the defined skins and deploys them
 *   to the <deploySkinRoot> directory (should be located in the game assets).
 *
 *   Packed skins are saved in a subdirectory <skinName> located in the
 *   <packedSkinRoot> directory.
 *
 *   Requires the rawFontRoot variable from the pixelateFonts configuration.
 *
 *   Path patterns for used
 *     fonts:           <rawFoontRoot>\<fontName>\fnt-*\[*.fnt,*.png]
 *     image resources: <rawSkinRoot>\<skinBase>\**\[*.png,*.jpg,*.jpeg]
 *                      <additionalResources>\**\[*.png,*.jpg,*.jpeg]
 *
 *   Supports the configuration of the texture packer via a pack.json located
 *   in <rawSkinRoot>\<skinBase>\ or <additionalResources>\ (not in a subdirectory).
 *   The pack.json in the additional resources overwrites the pack.json of the
 *   skin base.
 *
 *   Any files inside the <additionalResources> directory that aren't image
 *   resources will be copied into the directory of the packed skin (which means
 *   that these files will be also deployed). This could be used for the json that
 *   defines the skin licenses/attributions of assets.
 */
ext {
    rawSkinRoot = 'relative path to root folder of the skin resources'
    packedSkinRoot = 'destination for packed skins'
    deploySkinRoot = 'relative path to root folder of the skin assets (deploy destination)'
    skins = [
        ['skinName', 'fontName', 'skinBase', 'additionalResources (optional)']
    ]
}

// --------------------------------------------------------------------------------------------------------------------

buildscript {
	repositories {
	    mavenLocal()
	    mavenCentral()
	    maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
	    jcenter()
	}
    dependencies {
        classpath "com.badlogicgames.gdx:gdx-tools:$gdxTarget"
    }
}
    
ext {
    upseilGdxTools_workingDirectory = 'build/tmp/'
}

import com.badlogic.gdx.tools.texturepacker.TexturePacker
task packSkins (group: 'Asset') {
    description = 'Packs the skins and saves them in the packed skins directory.'
    doLast {
        for (String[] skin : skins) {
            String skinName = skin[0]
            String fontName = skin[1]
            String baseName = skin[2]
        
            String fontRootDir = rawFontRoot + '/' + fontName + '/'
            String skinBaseDir = rawSkinRoot + '/' + baseName + '/'
            
            println 'Collecting font ' + fontName + ': ' + fontRootDir
            FileTree fontTree = fileTree(dir: fontRootDir, includes: ['**/fnt-*/*.fnt', '**/fnt-*/*.png'])
            copy { from fontTree.files into upseilGdxTools_workingDirectory }
            
            println 'Collecting skin base ' + baseName + ': ' + skinBaseDir
            FileTree baseTree = fileTree(dir: skinBaseDir, includes: ['**/*.png', '**/*.jpg', '**/*.jpeg', 'pack.json'])
            copy { from baseTree.files into upseilGdxTools_workingDirectory }
            
            FileTree resourcesToCopy = null
            if (skin.length > 3) {
                String additionalResources = skin[3] + '/'
                println 'Collecting additional image resources: ' + additionalResources
                FileTree additionalTree = fileTree(dir: additionalResources, includes: ['**/*.png', '**/*.jpg', '**/*.jpeg', 'pack.json'])
                copy { from additionalTree.files into upseilGdxTools_workingDirectory }
                
                resourcesToCopy = fileTree(dir: additionalResources, excludes: ['**/*.png', '**/*.jpg', '**/*.jpeg', 'pack.json'])
            }
            
            String packedSkinDir = packedSkinRoot + '/' + skinName + '/'
            println 'Packing skin ' + skinName + ' into ' + packedSkinDir
            delete fileTree(dir: packedSkinDir)
            TexturePacker.process(upseilGdxTools_workingDirectory, packedSkinDir, skinName)
            copy {
                from upseilGdxTools_workingDirectory
                into packedSkinDir
                include '**/*.fnt'
            }
            
            if (resourcesToCopy != null) {
                copy { from resourcesToCopy.files into packedSkinDir }
            }
            
            delete fileTree(dir: upseilGdxTools_workingDirectory)
        }
    }
}

task deploySkins (group: 'Asset') {
    description = 'Packs the skins, saves them in the packed skins directory and deploys them to the game assets.'
    dependsOn packSkins
    doLast {
        for (String[] skin : skins) {
            String skinName = skin[0]
            String packedSkin = packedSkinRoot + '/' + skinName + '/'
            String target = deploySkinRoot + '/' + skinName + '/'
            
            println 'Deleting old skin files'
            delete fileTree(dir: target)
            
            println 'Deploying skin ' + skinName + ': ' + packedSkin + ' -> ' + target
            copy {
                from packedSkin
                into target
            }
        }
    }
}

task deploySkinsTraceless (group: 'Asset') {
    description = 'Packs the skins and deploys them to the game assets without saving the packed skin.'
    dependsOn deploySkins
    doLast {
        for (String[] skin : skins) {
            String skinName = skin[0]
            String packedSkin = packedSkinRoot + '/' + skinName + '/'
            
            println 'Deleting packed skin ' + skinName + ': ' + packedSkin
            delete packedSkin
        }
    }
}

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import javax.imageio.ImageIO;
task pixelateFonts (group: 'Asset') {
    description = 'Pixelates the configured fonts.'
    doLast {
        for (Object[] fontFamily : fontsToPixelate) {
            String familyName = fontFamily[0]
            String familyPath = rawFontRoot + '/' + familyName + '/'
            String pixelatedFamilyName = familyName + '-pixelated'
            String pixelatedFamilyPath = rawFontRoot + '/' + pixelatedFamilyName + '/'
            println 'Pixelating font family ' + familyName
            for (Object[] font : fontFamily[1]) {
                String fontSize = font[0]
                Color filter = Color.decode(font[1])
                Color transparent = new Color(0, true)
                double minAlpha = font[2]
                
                String fontPath = familyPath + 'fnt-' + fontSize + '/'
                String pixelatedFontPath = pixelatedFamilyPath + 'fnt-' + fontSize + '/'
                println '  Pixelating font fnt-' + fontSize + ':' + fontPath + ' -> ' + pixelatedFontPath
                
                String bitmapPath = fontPath + familyName + '-' + fontSize + '.png'
                BufferedImage bitmap = ImageIO.read(new File(bitmapPath))
                byte[] pixels = ((DataBufferByte) bitmap.getRaster().getDataBuffer()).getData()
                int x = 0;
                int y = 0;
                for (int pixelStart = 0; pixelStart < pixels.length; pixelStart += 4) {
                    int value = (((int) pixels[pixelStart] & 0xFF) << 24)     |  // alpha
                                (((int) pixels[pixelStart + 3] & 0xFF) << 16) |  // red
                                (((int) pixels[pixelStart + 2] & 0xFF) << 8)  |  // green
                                (((int) pixels[pixelStart + 1] & 0xFF) << 0);    // blue
                    Color color = new Color(value, true)
                    
                    if (color.getRed() == filter.getRed() &&
                        color.getGreen() == filter.getGreen() &&
                        color.getBlue() == filter.getBlue() &&
                        color.getAlpha() >= minAlpha) {
                            bitmap.setRGB(x, y, filter.getRGB())
                    } else {
                        bitmap.setRGB(x, y, transparent.getRGB())
                    }
                    
                    x++;
                    if (x == bitmap.getWidth()) {
                        x = 0;
                        y++;
                    }
                }
                
                String fntPath = fontPath + familyName + '-' + fontSize + '.fnt'
                copy {
                    from fntPath
                    into pixelatedFontPath
                    rename(familyName + '-' + fontSize + '.fnt',
                           pixelatedFamilyName + '-' + fontSize + '.fnt')
                }
                String pixelatedBitmapPath = pixelatedFontPath + pixelatedFamilyName + '-' + fontSize + '.png'
                ImageIO.write(bitmap, 'png', new File(pixelatedBitmapPath))
            }
        }
    }
}